import { PGlite } from '@electric-sql/pglite';
import * as valibot from 'valibot';
import { InferOutput } from 'valibot';

declare const DEFAULT_DATABASE_PORT = 51214;
declare const DEFAULT_SERVER_PORT = 51213;
declare const DEFAULT_SHADOW_DATABASE_PORT = 51215;
type PortAssignableService = DBServerPurpose | "server";
declare class PortNotAvailableError extends Error {
    port: number;
    service: PortAssignableService;
    name: string;
    constructor(port: number, service: PortAssignableService);
}

interface Server extends Exports {
    close(): Promise<void>;
}
declare function unstable_startServer(options?: ServerOptions): Promise<Server>;

declare const exportsSchema: valibot.ObjectSchema<{
    readonly database: valibot.ObjectSchema<{
        readonly connectionString: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
        readonly prismaORMConnectionString: valibot.OptionalSchema<valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>, undefined>;
        readonly terminalCommand: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    }, undefined>;
    readonly http: valibot.ObjectSchema<{
        readonly url: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
    }, undefined>;
    readonly ppg: valibot.ObjectSchema<{
        readonly url: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
    }, undefined>;
    readonly shadowDatabase: valibot.ObjectSchema<{
        readonly connectionString: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
        readonly prismaORMConnectionString: valibot.OptionalSchema<valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>, undefined>;
        readonly terminalCommand: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>;
type Exports = InferOutput<typeof exportsSchema>;
declare const serverDumpV1Schema: valibot.ObjectSchema<{
    readonly databasePort: valibot.SchemaWithPipe<readonly [valibot.NumberSchema<undefined>, valibot.IntegerAction<number, undefined>, valibot.MinValueAction<number, 1, undefined>]>;
    readonly exports: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly database: valibot.ObjectSchema<{
            readonly connectionString: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
            readonly prismaORMConnectionString: valibot.OptionalSchema<valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>, undefined>;
            readonly terminalCommand: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        }, undefined>;
        readonly http: valibot.ObjectSchema<{
            readonly url: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
        }, undefined>;
        readonly ppg: valibot.ObjectSchema<{
            readonly url: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
        }, undefined>;
        readonly shadowDatabase: valibot.ObjectSchema<{
            readonly connectionString: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>;
            readonly prismaORMConnectionString: valibot.OptionalSchema<valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.UrlAction<string, undefined>]>, undefined>;
            readonly terminalCommand: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        }, undefined>;
    }, undefined>, undefined>;
    readonly name: valibot.SchemaWithPipe<readonly [valibot.StringSchema<undefined>, valibot.MinLengthAction<string, 1, undefined>]>;
    readonly pid: valibot.OptionalSchema<valibot.SchemaWithPipe<readonly [valibot.NumberSchema<undefined>, valibot.IntegerAction<number, undefined>, valibot.MinValueAction<number, 0, undefined>]>, undefined>;
    readonly port: valibot.SchemaWithPipe<readonly [valibot.NumberSchema<undefined>, valibot.IntegerAction<number, undefined>, valibot.MinValueAction<number, 1, undefined>]>;
    readonly shadowDatabasePort: valibot.SchemaWithPipe<readonly [valibot.NumberSchema<undefined>, valibot.IntegerAction<number, undefined>, valibot.MinValueAction<number, 1, undefined>]>;
    readonly version: valibot.LiteralSchema<"1", undefined>;
}, undefined>;
type ServerDumpV1 = InferOutput<typeof serverDumpV1Schema>;
interface ServerOptions {
    /**
     * The port the database server will listen on.
     *
     * Defaults to `51214`.
     *
     * An error is thrown if the port is already in use.
     */
    databasePort?: number;
    /**
     * Whether to enable debug logging.
     *
     * Defaults to `false`.
     */
    debug?: boolean;
    /**
     * Whether to run the server in dry run mode.
     *
     * Defaults to `false`.
     */
    dryRun?: boolean;
    /**
     * The name of the server.
     *
     * Defaults to `default`.
     */
    name?: string;
    /**
     * The persistence mode of the server.
     *
     * Default is `stateless`.
     */
    persistenceMode?: PersistenceMode;
    /**
     * The port the server will listen on.
     *
     * Defaults to `51213`.
     *
     * An error is thrown if the port is already in use.
     */
    port?: number;
    /**
     * The port the shadow database server will listen on.
     *
     * Defaults to `51215`.
     *
     * An error is thrown if the port is already in use.
     */
    shadowDatabasePort?: number;
}
type ResolvedServerOptions = Required<ServerOptions>;
type PersistenceMode = "stateless" | "stateful";
interface ScanOptions {
    debug?: boolean;
}
declare const PRIVATE_INITIALIZE_SYMBOL: unique symbol;
declare abstract class ServerState implements ResolvedServerOptions {
    readonly databasePort: number;
    readonly debug: boolean;
    readonly dryRun: boolean;
    readonly name: string;
    readonly persistenceMode: PersistenceMode;
    readonly pid: number | undefined;
    readonly port: number;
    readonly shadowDatabasePort: number;
    protected constructor(options: Omit<ServerOptions, "persistenceMode"> & {
        persistenceMode: PersistenceMode;
        pid: number | undefined;
    });
    static createExclusively(options: ServerOptions | undefined): Promise<ServerState>;
    static fromServerDump(options?: Pick<ServerOptions, "debug" | "name">): Promise<StatefulServerState | null>;
    static scan(options?: ScanOptions): Promise<ServerStatusV1[]>;
    abstract get databaseDumpPath(): string;
    abstract get pgliteDataDirPath(): string;
    abstract [PRIVATE_INITIALIZE_SYMBOL](): Promise<void>;
    abstract close(): Promise<void>;
    abstract writeServerDump(exports?: Omit<Server, "close">): Promise<void>;
}
declare class StatefulServerState extends ServerState {
    #private;
    constructor(options: Omit<ServerOptions, "persistenceMode"> & {
        pid: number | undefined;
        serverDump?: ServerDumpV1;
    });
    static getServerDumpPath(dataDirPath: string): string;
    get databaseDumpPath(): string;
    get exports(): Exports | undefined;
    get pgliteDataDirPath(): string;
    [PRIVATE_INITIALIZE_SYMBOL](): Promise<void>;
    close(): Promise<void>;
    writeServerDump(exports?: Exports): Promise<void>;
}
interface ServerStatusV1 extends ServerDumpV1 {
    status: "running" | "starting_up" | "not_running" | "no_such_server" | "unknown" | "error";
}
declare class ServerStateAlreadyExistsError extends Error {
    name: string;
    constructor(name: string);
}

interface DBServer {
    close(): Promise<void>;
    readonly connectionLimit: number;
    readonly connectionString: string;
    readonly connectTimeout: number;
    readonly database: string;
    dump(destinationPath: string): Promise<void>;
    readonly maxIdleConnectionLifetime: number;
    readonly password: string;
    readonly poolTimeout: number;
    readonly port: number;
    readonly prismaORMConnectionString: string;
    readonly socketTimeout: number;
    readonly sslMode: string;
    readonly terminalCommand: string;
    readonly username: string;
}
interface DBDump {
    dumpPath: string;
}
type DBServerPurpose = "database" | "shadow_database";
declare function startDBServer(purpose: DBServerPurpose, serverState: ServerState): Promise<DBServer>;
type DumpDBOptions<D extends string> = {
    dataDir: string;
    db?: never;
    debug?: boolean;
    destinationPath?: D;
} | {
    dataDir?: never;
    db: PGlite;
    debug?: boolean;
    destinationPath?: D;
};
declare function dumpDB<D extends string = never>(options: DumpDBOptions<D>): Promise<[D] extends [never] ? string : void>;

export { DEFAULT_DATABASE_PORT as D, type Exports as E, type PortAssignableService as P, type ResolvedServerOptions as R, type ServerOptions as S, type Server as a, DEFAULT_SERVER_PORT as b, DEFAULT_SHADOW_DATABASE_PORT as c, PortNotAvailableError as d, type ServerDumpV1 as e, type PersistenceMode as f, type ScanOptions as g, ServerState as h, type ServerStatusV1 as i, ServerStateAlreadyExistsError as j, type DBServer as k, type DBDump as l, type DBServerPurpose as m, type DumpDBOptions as n, dumpDB as o, startDBServer as s, unstable_startServer as u };
