import { A as Adapter, T as Table, F as FilterOperator, Q as Query, b as AdapterInsertDetails, B as BuilderRequirements, c as AdapterQueryDetails, d as AdapterUpdateDetails, e as AdapterDeleteDetails } from '../../query-BhV8UH4b.js';
import { Executor } from '../index.js';
import * as kysely from 'kysely';

interface PostgresAdapterRequirements {
    executor: Executor;
    noParameters?: boolean;
}
declare function createPostgresAdapter(requirements: PostgresAdapterRequirements): Adapter;
/**
 * For testing purposes.
 */
declare function mockIntrospect(): {
    schemas: { [K in "zoo" | "public"]: {
        name: K;
        tables: { [T in "animals" | "users"]: Table; };
    }; };
    timezone: "UTC";
    filterOperators: FilterOperator[];
    query: Query;
};

/**
 * `ctid` is a system column that represents the physical location of a row in a table.
 * It is a tuple of two integers: `(blockNumber, tupleIndex)`.
 * It is used to uniquely identify a row in a table, even if the row has no primary key, or other unique constraints.
 *
 * Example: '(0,23)' represents the 24th row in the first block of the table.
 */
type CTIDasText = `(${number},${number})`;
/**
 * Inserts one or more rows into a table and returns the inserted rows along with their `ctid`.
 */
declare function getInsertQuery(details: AdapterInsertDetails, requirements?: Omit<BuilderRequirements, "Adapter" | "QueryCompiler">): Query<{
    [x: string]: unknown;
} & {
    ctid: `(${number},${number})`;
}>;
/**
 * Returns a query that selects all columns from a table, along with the `ctid` column, and unbound row count as `oid` (reserved column name that cannot conflict with user columns).
 */
declare function getSelectQuery(details: AdapterQueryDetails, requirements?: Omit<BuilderRequirements, "Adapter" | "QueryCompiler">): Query<{
    [x: string]: unknown;
    oid: `${bigint}`;
    ctid: `(${number},${number})`;
}>;
/**
 * For testing purposes.
 */
declare function mockSelectQuery(): [{
    readonly created_at: Date;
    readonly ctid: "(0,1)";
    readonly deleted_at: null;
    readonly id: 1;
    readonly name: "John Doe";
    readonly oid: "2";
    readonly role: "admin";
    readonly name_role: "Jonn Doe - admin";
}, {
    readonly created_at: Date;
    readonly ctid: "(0,2)";
    readonly deleted_at: null;
    readonly id: 2;
    readonly name: "Jane Doe";
    readonly oid: "2";
    readonly role: "poweruser";
    readonly name_role: "Jane Doe - poweruser";
}];
/**
 * Returns a query that updates a given row in a table with given changes.
 */
declare function getUpdateQuery(details: AdapterUpdateDetails, requirements?: Omit<BuilderRequirements, "Adapter" | "QueryCompiler">): Query<{
    [x: string]: unknown;
    ctid: `(${number},${number})`;
    __ps_updated_at__: `${bigint}`;
}>;
/**
 * Returns a query that deletes a given set of rows.
 */
declare function getDeleteQuery(details: AdapterDeleteDetails, requirements?: Omit<BuilderRequirements, "Adapter" | "QueryCompiler">): Query<kysely.DeleteResult>;

/**
 * Returns a query that returns metadata for all user-defined tables and views in the database.
 */
declare function getTablesQuery(requirements?: Omit<BuilderRequirements, "Adapter" | "QueryCompiler">): Query<{
    schema: string;
    name: string;
    columns: {
        name: string;
        datatype: string;
        datatype_schema: string;
        foreign_key_schema: string | null;
        foreign_key_table: string | null;
        foreign_key_column: string | null;
        pk: boolean;
        computed: boolean;
        nullable: boolean;
        options: string[];
    }[];
}>;
/**
 * For testing purposes.
 */
declare function mockTablesQuery(): [{
    readonly schema: "zoo";
    readonly name: "animals";
    readonly columns: [{
        readonly name: "id";
        readonly datatype: "int4";
        readonly datatype_schema: "pg_catalog";
        readonly pk: true;
        readonly computed: false;
        readonly options: [];
        readonly nullable: false;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }, {
        readonly name: "name";
        readonly datatype: "text";
        readonly datatype_schema: "pg_catalog";
        readonly pk: false;
        readonly computed: false;
        readonly options: [];
        readonly nullable: true;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }];
}, {
    readonly schema: "public";
    readonly name: "users";
    readonly columns: [{
        readonly name: "id";
        readonly datatype: "int4";
        readonly datatype_schema: "pg_catalog";
        readonly pk: true;
        readonly computed: false;
        readonly options: [];
        readonly nullable: false;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }, {
        readonly name: "created_at";
        readonly datatype: "timestamp";
        readonly datatype_schema: "pg_catalog";
        readonly pk: false;
        readonly computed: false;
        readonly options: [];
        readonly nullable: true;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }, {
        readonly name: "deleted_at";
        readonly datatype: "timestamp";
        readonly datatype_schema: "pg_catalog";
        readonly pk: false;
        readonly computed: false;
        readonly options: [];
        readonly nullable: true;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }, {
        readonly name: "role";
        readonly datatype: "varchar";
        readonly datatype_schema: "pg_catalog";
        readonly pk: false;
        readonly computed: false;
        readonly options: [];
        readonly nullable: true;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }, {
        readonly name: "name";
        readonly datatype: "varchar";
        readonly datatype_schema: "pg_catalog";
        readonly pk: false;
        readonly computed: false;
        readonly options: [];
        readonly nullable: true;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }, {
        readonly name: "name_role";
        readonly datatype: "text";
        readonly datatype_schema: "pg_catalog";
        readonly pk: false;
        readonly computed: true;
        readonly options: [];
        readonly nullable: false;
        readonly foreign_key_schema: null;
        readonly foreign_key_table: null;
        readonly foreign_key_column: null;
    }];
}];
/**
 * Returns a query that returns the current timezone setting of the PostgreSQL database.
 */
declare function getTimezoneQuery(): Query<{
    timezone: string;
}>;
/**
 * For testing purposes.
 */
declare function mockTimezoneQuery(): [{
    readonly timezone: "UTC";
}];

export { type CTIDasText, type PostgresAdapterRequirements, createPostgresAdapter, getDeleteQuery, getInsertQuery, getSelectQuery, getTablesQuery, getTimezoneQuery, getUpdateQuery, mockIntrospect, mockSelectQuery, mockTablesQuery, mockTimezoneQuery };
